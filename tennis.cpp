#include <graphics.h>
#include <iostream.h>
#include <conio.h>
#include <dos.h>
#include <stdlib.h>
// Класс точки на экране.
class point
{
 protected:	// Защищенные данные класса:
  int x, y;     //Координаты точки
  // Прототипы общедоступных компонентных функций:
 public:
  // Конструктор с параметрами.
  point(int xi  = 0, int yi  = 0);
  int& givex(void);  // Доступ к х
  int& givey(void);  // Доступ к у
  void show(void);   // Изобразить точку на экране
  // Переместить точку в новое место экрана:
  // (хn=0, уn=0 - умалчиваемые значения параметров)
  void move(int xn = 0, int yn = 0);
 private:  // Собственная функция класса:
  void hide();    // Убрать с экрана изображение точки
};
//***************************
// Описание функций класса.
//***************************
// Описание конструктора класса.
point::point(int xi, int yi)
 {x=xi; y=yi;} // определение данных объекта
// Описание функций доступа к координатам центра
// Описание функции изображения точки на экране
void point::show(void)
  // окрашивает пиксель с координатами
  // X, Y  текущим цветом рисунка
 {putpixel(x,y,getcolor());}
// Убрать с экрана изображение точки
void point::hide(void)
  // аналогично, но цветом фона
 {putpixel(x,y,getbkcolor());}
// Переместить точку на новое место экрана
// с координатами XN, YN.
void point::move(int xn, int yn)
 {
  // вначале убираю с экрана текущую точку
  hide();
  // устанавливаю новые координаты точки
  x=xn; y=yn;
  // изображаю на экране точку на новом месте
  show();
 }
// Класс работы с пятном на экране.
// 'public'  позволит сохранить статусы доступа
// для наследуемых компонентов класса POINT:
class  spot:public point
{
 // Статус доступности данных в производном классе:
 protected:
  int rad;	// Радиус пятна (изображения)
  int vis;	// Видимость пятна на экране
  int tag;	// Признак сохранения образа в памяти
  void *pspot;  // Указатель на область памяти для
		// изображения (для битового образа)
 public:
  // Конструктор класса SPOT:
  spot(int xi,  int yi,  int  ri):
  // Вызов конструктора базового класса:
  point(xi,yi)
   {
    vis=tag=0; rad = ri;
    // Определить размеры битового образа и
    // выделить память для него. Размер
    // определяю задав координаты ЛЕВЫЙ
    // ВЕРХНИЙ и ПРАВЫЙ НИЖНИЙ.
    pspot = new char[imagesize(xi-ri,yi-ri,xi+ri,yi+ri)];
   }
  ~spot()	// Деструктор класса SPOT
   {
    hide();     // Убрать с экрана изображение пятна
    tag =0;    // Сбросить признак сохранения в памяти
    delete pspot; // Освободить память битового образа
   }
  // Описание функции изображения пятна на экране
  void show ()
   {  // Если битового образа НЕТ в памяти:
    if (!tag)
     { // Нарисовать текущим цветом на экране
       // окружность указанного радиуса и центра:
      circle(x,y,rad);
      // Закрасить уже ограниченную зону цветов
      // границы, где X,Y  внутренние точки зоны
      floodfill(x,y,getcolor()) ;
      // Запомнить битовый образ в памяти:
      getimage(x-rad,y-rad,x+rad,y+rad,pspot);
      // взвод признака сохранения в памяти
      tag=1;
     }
    // Если ЕСТЬ, то
    else
    // Перенести изображение из памяти на экран
    // начиная с ЛЕВОГО ВЕРХНЕГО, СКОЛЬКО,
     putimage(x-rad,y-rad,pspot,XOR_PUT);
    vis=1;
   }
  // Описание функции убирания пятна с экрана
  void hide()
   {
    // Выход, если нечего убирать
    if (!vis) return;
    // Иначе стереть изображение с экрана:
    putimage(x-rad,y-rad,pspot,XOR_PUT);
    // взвожу признак очистки экрана
    vis=0;
   }
  // Переместить изображение:
  void move(int xn,  int yn)
   {
    hide(); // Убрать старое изображение с экрана
    // Изменить координаты центра пятна:
    x=xn; y=yn;
    show(); // Вывести изображение в новом месте
   }
   void hider()//Процедура стирание прямоугольника
   {
    // Выход, если нечего убирать
    if (!vis) return;
    // Иначе стереть изображение с экрана:
    putimage(x,y,pspot,XOR_PUT);
    // взвожу признак очистки экрана
    vis=0;
   }
   void mover(int xn,int yn)//Процедура переноса прямоугольника
   {
   hider();
   x=xn;y=yn;
   showr();
   }
 void showr ()//Процедура рисовки прямоугольника
   {  // Если битового образа НЕТ в памяти:
    if (!tag)
     { // Нарисовать текущим цветом на экране
       // прямоугольник в заданном месте:
      rectangle(x,y,x+5,y+rad);
      // Закрасить уже ограниченную зону цветов
      // границы, где X,Y  внутренние точки зоны
      floodfill(x,y,getcolor()) ;
      // Запомнить битовый образ в памяти:
      getimage(x,y,x+5,y+rad,pspot);
      // взвод признака сохранения в памяти
      tag=1;
     }
    // Если ЕСТЬ, то
    else
    // Перенести изображение из памяти на экран
    // начиная с ЛЕВОГО ВЕРХНЕГО, СКОЛЬКО,
     putimage(x,y,pspot,XOR_PUT);
    vis=1;
   }
};

void main ()
 { // Переменные для инициализации графики:
  int dr=DETECT,  mod,sc,p1=0,ch,p2=0,kol,i,j,dv=5,i1,j1,i2,j2;
  char s1[10],s2[10],n1[25],n2[25];
  // Инициализация графической системы:
     clrscr();//Очистка экрана
     cout<<"Введите скорость(1-100):";
     cin>>sc; //Ввод множителя для задержки перемещения пятна А
     cout<<"\nКоличество игр:";
     cin>>kol;//Количество игр
     cout<<"Введите имя 1-ого игрока:";
     cin>>n1;//Имя первого игрока
     cout<<"Введите имя 2-ого игрока:";
     cin>>n2;//Имя второго игрока
     clrscr(); //Очистка экрана
  initgraph(&dr,&mod,"c:\\common\\borlandc\\bgi\\");
   {
   // В этом блоке создаются и используются
     // объекты класса spot.
     // Через конструктор с параметрами создаю
     // два объекта (их будет не видно, но все готово).
     // Вызываю конструктор с параметрами,
     // создающий объект А, а фактически
     i1=10;//Начальная позиция прямоугольника 1ого игрока по оси X
     j1=205;//Начальная позиция прямоугольник 1ого игрока по оси Y
     i2=630;//Позиция прямоугольника 2ого игрока по оси Х
     j2=205;//Позиция прямоугольника 2ого игрока по оси Y
     i=320;//Начальное положение
     j=240;// пятна А
     spot A(i,j,3);  // Создается невидимое пятно А
     spot P1(i1,j1,50);// Создается невидимый прямоугольник 1ого игрока
     spot P2(i2,j2,50);// Прямоугольик 2ого игрока
     randomize();
     A.show();     // Вывод пятна А на экране
     P1.showr();//Вывод прямоугольника 1ого игрока на экран
     P2.showr();//Вывод прямоугольника 2ого игрока на экран
	setcolor(YELLOW);//Установка желтого цвета
	outtextxy(10,10,n1);//Вывод на экран имени 1ого игрока
	outtextxy(10,20,"Score:");//Вывод надписи счета для 1ого игрока
	itoa(p1,s1,10);//Перевод счета в строковый параметр
	outtextxy(60,20,s1);//Вывод счета на экран
	outtextxy(550,10,n2);//Вывод на экран имени 2ого игрока
	outtextxy(550,20,"Score:");//Ввывод надписи счета для 2ого игрока
	itoa(p2,s2,10);//Перевод числа счета для 2ого игрока в строковый параметр
	outtextxy(600,20,s2);//Вывод на эран счета для 2ого игрока
	setcolor(BROWN);//Активный цвет коричневый
	line(320,0,320,480);//Провести линию для разделения экрана на 2 части
     do//Цикл действий программы
     //определение поведени пятна А и его взаимосвязь с границами экрана
     {
      if((dv==2)&&(j-1<=5))dv=1;//Отражение от
      if((dv==4)&&(j-1<=5))dv=3;//верхней границы экрана

      if((dv==1)&&(j+1>=475))dv=2;//Отражение от
      if((dv==3)&&(j+1>=475))dv=4;//нижней границы экрана

      if((i-1<=i1+5)&&(j>=j1-3)&&(j<=j1+55))//Если пятно попадает в область
      //прямойгольника 1ого игрока
      {
      if(dv==3)dv=1;     //Отражение от
      if(dv==4)dv=2;     //прямоугольника 1ого игрока
      }

      if(i-1<=5)//Если пятно не попало по прямоугольнику 1ого игрока
      {
      dv=5; //остановить движение пятна А
      setcolor(BLACK);//Текущий цвет - черный
      outtextxy(600,20,s2);//Закрасить текст предыдущего счета
      setcolor(YELLOW);//Желтый цвет активен
      p2++;//Изменение переменной счета
      itoa(p2,s2,10);//Перевод счета в строковый параметр
      outtextxy(600,20,s2);//Вывод счета на экран
      kol--;//Уменьшить переменную количества игр
      i=320;        //Поместить
      j=240;        //пятно А в
      A.move(i,j);  //середину экрана
      if(kol==0)ch=27;//Если число игр равно 0 выйти
      }

    if((i+1>=i2-5)&&(j>=j2-3)&&(j<=j2+55))//Сопоставление прямоугольника
    //2ого игрока и пятна А
      {
      if(dv==1)dv=3;     //Отражение движения
      if(dv==2)dv=4;     //от прямоугольника 2ого игрока
      }

      if(i+1>=640)//Если пятно не попало по прямоугольнику 2ого игрока
      {
      dv=5;//Остановить пятно А
      setcolor(BLACK);//Установить черный цвет
      outtextxy(60,20,s1);//закрасить предыдущий счет
      setcolor(YELLOW);//установит жултый цвет
      p1++;//увеличить переменную счета
      itoa(p1,s1,10);//перевести в строковый формат
      outtextxy(60,20,s1);//Вывод на экран измененного счета
      kol--;//Уменьшение количества игр
      i=320;             //Возращение
      j=240;             //пятна А
      A.move(i,j);       //в центр экрана
      if(kol==0)ch=27;//Если все игры сыграны - выход
      }

      switch(dv)//Изменение движение пятна А
      {//относительно заданного направления
       case 1: i+=1;j+=1;break;
       case 2: i+=1;j-=1;break;
       case 3: i-=1;j+=1;break;
       case 4: i-=1;j-=1;break;
       Default: break;
      }
     A.move(i,j);// Переместить пятно A
     if(kbhit())//Если нажата клавиша
     {
      ch=getch();//Запомнить код нажатой клавиши
      //Игрок 1 может двигать только если пятно А
      if((dv==3)||(dv==4)){// движется в его сторону
      if ((ch==75)&&(i1-5>=5))i1-=5;//Если нажата стрелка влево изменить
				    //координаты прямоугольника влево
      if ((ch==77)&&(i1+5<=310))i1+=5;//Если нажата стрелка вправо изменить
				      //координаты прямоугольника вправо
      if((ch==72)&&(j1-5>=5))j1-=5;//при нажатии клавиши вверх, изменить
      //координаты
      if((ch==80)&&(j1+5<=425))j1+=5;//при нажатии клавиши вниз
      //изменить координаты
      }
      //Игрок 2 может двигать только если
      if((dv==1)||(dv==2)){//пятно А движется в его сторону
      if((ch==97)&&(i2-5>=330))i2-=5;//влево=А
      if((ch==100)&&(i2+5<=630))i2+=5;//вправо=D
      if((ch==119)&&(j2-5>=5))j2-=5;//вверх=W
      if((ch==115)&&(j2+5<=425))j2+=5;//вниз=S
      }

      if ((ch==13)&&(dv==5))dv=random(4)+1;//Если нажата клавиша Ентер и
					   //пятно А без движения изменить движение пятна
      P1.mover(i1,j1);//Показать на экране новое положение 1ого прямоугольника
      P2.mover(i2,j2);//Показать на экране новое положение 2ого прямоугольника
     }
     delay(5*sc);//Задержка при перемещении пятна А
     }
     while(ch!=27);//Выход из цикла по нажатию на Enter
	setcolor(LIGHTGREEN);//Установить салатовый цвет
	if(p1>p2)outtextxy(260,200,"Игрок 1 победил!");
	if(p2>p1)outtextxy(260,200,"Игрок 2 победил!");
	outtextxy(260,150,"<<<GAME OVER>>>");
     getch();
}
  // При выходе из блока для каждого объекта автоматически
  // вызывается деструктор, освобождающий выделенную память
  closegraph();	// Закрыть графический режим
 } // Конец программы
